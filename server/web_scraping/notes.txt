Ideas for graphs: 

1. Most common months for deaths - line graph 
2. Graph of all deaths by age - Data for this graph is done - Graph Built 
3. Top 3 deadliest expeditions - Data for this graph is ready - Graph Built 
4. Top 3 nationalies - Data for this graph is ready. - Graph Built 
5. Top 3 or 5 causes of death - Data for this graph is ready.  
6. Top 3 locations for deaths 

Previous Project Help: 
Graph: 
https://github.com/ravenusmc/israel_project/blob/main/client/src/components/graphs/Avgage.vue

More: 
https://github.com/ravenusmc/israel_project/tree/main/client/src/components/graphs

Forms: 
https://github.com/ravenusmc/israel_project/tree/main/client/src/components/DataPage

https://github.com/ravenusmc/israel_project/blob/main/client/src/components/DataPage/Injuryform.vue


Chat GPT ideas: 

Heat Maps:

Deaths per Year vs. Nationality: A heat map showing which nationalities had more deaths in which years.

Location vs. Cause of Death: A heat map showing which locations are most associated with specific causes of death.

Linear Regression: 

Age vs. Year: See if there is a trend in climbersâ€™ ages over time.

Deaths per Expedition Year: Regression of number of deaths over time to see if safety is improving.

Other Graphs: 

Time Series: Plot total deaths per year to see peaks during major expeditions.

Pie Chart or Bar Plot: Proportion of deaths by cause (avalanche, fall, exposure, etc.).

Stacked Bar: Number of deaths by nationality over time.

Map Plot: If you can geo-locate the Location, a map heat map could show dangerous spots on Everest.


Drill Down code: 
https://github.com/ravenusmc/missing_411_project/blob/main/client/src/components/graphs/TopFiveGraphs.vue

https://github.com/ravenusmc/missing_411_project/blob/main/client/src/components/graphs/Old.vue

Old Code: 

<!-- May go back to the input...not sure-->
<!-- <div>
    <label>Enter Number of States to see:</label>
    <input v-model="numberOfStates" />
</div> -->


  async getDataForDrillDown(payload) {
    console.log('Action')
    console.log(payload)
    try {
      const res = await axios.post('http://localhost:5000/getDataForDrillDown', payload);
      return res.data
    }catch (error) {
			console.error('Error in drilldown action:', error);
			throw error;
		}
  },



Location
: 
"Hillary Step"
Remains status
: 
"Died while descending, waiting for recovery"

Age
: 
"45"
Cause_of_Death
: 
"Altitude sickness"
Date
: 
"May 15, 2025"
Expedition
: 
"Snowy Horizon Treks"
Location
: 
"Hillary Step"
Name
: 
"Subrata Ghosh"
Remains status
: 
"Died while descending, waiting for recovery"
[[Prototype]]
: 
Object


// const path = 'http://localhost:5000/getDataForDrillDownGraphs';
// axios.post(path, payload)
// .then((res) => {
//     console.log(res.data)
// 		commit('setStatesDeathsDrillDown', 5)
//     return res.data
// })
// .catch((error) => {
// 	console.log(error);
// });


  // getDataForDrillDown: ({commit}, {payload}) => {
//   const path = 'http://localhost:5000/getDataForDrillDownGraphs';
//   axios.post(path, payload)
// 	.then((res) => {
// 			commit('setStatesDeathsDrillDown', 5)
//       return res.data
// 	})
// 	.catch((error) => {
// 		console.log(error);
// 	});
// },

Works but did not like commit:
async getDataForDrillDown ({commit}, payload) {
    try {
			// Perform an asynchronous operation, for example, an API call
			const res = await axios.post('http://localhost:5000/getDataForDrillDownGraphs', payload);
			// Return the data from the response
      commit('setStatesDeathsDrillDown', 5)
			return res.data;
		} catch (error) {
			console.error('Error in drilldown action:', error);
			throw error;
		}
  },

# Example of how not to have anthing in first parameter. 
async getDataForDrillDown (_, payload) 


  # def top_nations_data(self, number_of_nations, startDate, endDate): 
  #   top_nations = []
  #   # Clean the date_time column 
  #   self.data['Date_clean'] = pd.to_datetime(self.data['Date'].str.extract(r'(\w+ \d{1,2}, \d{4})')[0], errors='coerce')
  #   # Group by Nationality and count number of rows (deaths)
  #   counts = (
  #       self.data.groupby('Nationality')
  #       .size()
  #       .reset_index(name='Death Count')
  #   )
  #   # Drop missing or empty Nationality values
  #   counts = counts[counts['Nationality'].notnull() & (counts['Nationality'] != '')]
  #   # Sort by Death Count descending and take top 3
  #   nations = counts.sort_values(by='Death Count', ascending=False).head(number_of_nations)
  #   count = 0
  #   while count < number_of_nations:
  #     rows = []
  #     state = nations.iloc[count][0]
  #     deaths = int(nations.iloc[count][1])
  #     rows.append(state)
  #     rows.append(deaths)
  #     top_nations.append(rows)
  #     count += 1 
  #   return top_nations


    def drilldown_states_graph(self, selected_state, startDate, endDate):
    # Clean and parse the Date column
    self.data['Date_clean'] = pd.to_datetime(
        self.data['Date'].str.extract(r'(\w+ \d{1,2}, \d{4})')[0],
        errors='coerce'
    )
    # Convert input start/end dates to datetime
    start_dt = pd.to_datetime(startDate)
    end_dt = pd.to_datetime(endDate)
    
    # Filter by state and date range
    filtered_data = self.data[
        (self.data['Date_clean'] >= start_dt) &
        (self.data['Date_clean'] <= end_dt) &
        (self.data['Nationality'] == selected_state) &
        (self.data['Date_clean'].notnull())
    ]
    # Define the columns you want to keep
    selected_columns = [
        'Name', 'Date', 'Age', 'Expedition',
        'Cause_of_Death', 'Location', 'Remains status'
    ]
    filtered = filtered_data[selected_columns]
    # Convert to list of dictionaries and replace NaNs with None
    drilldown_data = filtered.to_dict(orient='records')
    for row in drilldown_data:
        for key in row:
            if pd.isna(row[key]):
                row[key] = None
    return drilldown_data
